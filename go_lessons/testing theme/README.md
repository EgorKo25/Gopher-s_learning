## Package Testing
    import "testing"
    
    func SomthingFunc(x int){return x}    

    func TestSomthingFunc(t *testing.T){
         x := 5
         t.Run("test", func(){
              if res := SomthingFunc(x); res != x{обработка не пройденного теста}
          })
    }
## Обработчики
### t.Errorf()
 записывает сообщение в error-лог и помечает тест как непройденный. Исполнение теста продолжается.
### t.Fatalf()
 делает то же самое. Но исполнение теста немедленно завершается. Этот метод часто используется в рабочих проектах при обработке ошибок.
### t.Skipf() 
 позволяет пропустить тест с сообщением. Используется, когда окружение для теста не задано. Типичный сценарий — прогон интеграционных тестов с внешним сервисом только на CI, где к нему есть доступы.
### t.Logf() 
позволяет выводить лог-сообщения внутри теста. Преимущество перед методами пакета fmt в том, что из лога сразу видно, к какому тесту относится сообщение.

Хорошая практика — для каждой функции сделать несколько тестов с разными значениями, в том числе учесть пограничные случаи (edge cases). Для этого создаётся слайс из тестов.

### Задания с первого по третье (task1 - task3) 
- покрыть тестами предоставленные программы
- все тесты в файле test_main.go
### Запуск тестов командой
     go test

> **Тема тестировнаия HTTP сервера** \
> будет в соседней папке